---
layout: default
title:  "Rust学习笔记（九）泛式，特征和生命周期"
date:   2020-06-25 15:25:04 +0800
categories: 
---

# Rust学习笔记 （九）泛式，特征和生命周期
#ProgrammingLanguage/Rust

## 泛式数据类型：
在前几章的内容中，其实就有用到泛式类型。
* Option<T>
* Vec<T>
* HashMap<K, V>
* Result<T, E>

可以简单的将泛式类型，理解为具体类型的抽象替代品。在rust中可以使用泛式定义的函数，结构体，枚举，和方法（methods）。

### 泛式函数定义

**将多个类似的输入不同类型参数的函数，抽象成一个输入泛式类型参数的函数（类似C++的重用）**

在以往的编程经验中，特别在C里，会需要处理不同类型的输入参数，但是函数题本身十分类似，如下代码，会显得程序臃肿且重复，写起来也特别没有积极性。
```rust
fn largest_i32(list: &[i32]) -> i32 {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn largest_char(list: &[char]) -> char {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&char_list);
    println!("The largest char is {}", result);
}
```

在rust里面，可以将上面的两个相似的函数，合并为一个泛式函数。下面的代码，仍会报错，原因稍后讲解。
```rust
fn largest<T>(list: &[T]) -> T {
    let mut largest = list[0];

    for &item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&char_list);
    println!("The largest char is {}", result);
}

$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `>` cannot be applied to type `T`
 --> src/main.rs:5:17
  |
5 |         if item > largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
```

语法解释： rust默认使用<>括号，表示泛式类型，取type的缩写，一般会使用T这个名称，不过也可以是其他的名字。

如果要在函数体中使用泛式类型的变量，就需要在函数定义的时候申明参数名称， **function_name <T> ()**, 如果有两种不同泛式类型，可以写作，
**function_name <T， U> ()**。

上述代码仍有问题无法编译通过，编译报错提示，目前的代码里，largest函数无法在T所能代表的所有可能的类型上，正常运行。

因为我们要比较函数体中T类型的值，所以只能使用其值可以排序的数据类型。如果启用比较，标准库有 std::cmp::PartialOrd trait，可以使用在数据类型上。这种在泛式数据类型上指定特定的trait的行为，被叫做**Trait Bounds(train界限)**

### 结构体中定义泛式类型参数
```rust
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
```
和泛式函数的定义类似，泛式结构体定义 **struct struct_name <T>**

这里需要注意一下，因为只定义了一种泛式类型T，在程序看来，结构中的x和y是一个类型。

在main函数中的调用，就会报错，编译的时候，认为x是i32 ,y是float是两种类型的数据。这个时候，就必须使用多个泛式类型参数了。

``` rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```

### 枚举中定义泛式类型参数
``` rust
enum Option<T> {
    Some(T),
    None,
}
```
这个时候再来看Option就会有更深一层的理解。
这是一个泛式类型T的枚举，这个枚举有两个变量：Some（泛式类型T的一个值）和None（没有任何类型的值）。

和结构体类似，枚举也可以使用多个不同类型的泛式数据。
``` rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```
枚举Result ，有两个泛式数据类型T和E，有两个变量，其中Ok是T的可能的一个具体类型，Err是E可能的一个具体类型。
如果在以下示例代码中：
``` rust
use std::fs::File;
fn main() {
	let f = File::open("hello.txt");
	let f = match f { 
		Ok(file) => file, 
		Err(error) => {
			panic!("There was a problem opening the file: {:?}", 			error) 
		},
	}; 
}
```
如果文件打开正确，T实际代表的是数据类型是std::fs::File，如果文件打开报错，E实际代表的数据类型是std::io::Error。

在代码中如果有多个结构或枚举定义，这些数据结构仅在它们所持有的值的类型上有所不同的话，可以通过使用泛型类型来避免重复。

### 在method中定义泛式类型
``` rust
struct Point<T> {
    x: T,
    y: T,
}

impl<T> Point<T> {
    fn x(&self) -> &T {
        &self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!("p.x = {}", p.x());
}
```
通过在impl之后将T声明为通用类型，Rust可以识别Point中尖括号中的类型是通用类型，而不是具体类型。

结构定义中的泛型类型参数可以与你在该结构的method定义中使用的参数不相同。
``` rust
struct Point<T, U> {
    x: T,
    y: U,
}

impl<T, U> Point<T, U> {
    fn mixup<V, W>(self, other: Point<V, W>) -> Point<T, W> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}

```
上面这个例子的目的，是为了演示这么一种情况，有一些泛式参数在impl申明，还有一些泛式参数在method申明。

## Traits：定义共通行为
⚠️traits告诉rust编译器，特定类型具有的功能，并可以与其他类型共享。
我们可以使用traits bounds（特征限制范围）来指定泛式类型可以是具有特定行为的任何类型。

### Defining a Trait
一个类型的行为，由我们可以在该类型上调用的所有methods组成。
如果我们可以在所有类型上调用相同的methods，则不同的类型具有相同的行为。
trait 定义是一种将method 定义组合在一起，以定义完成某种目的所必须的行为。

举个例子，我们有多种结构，结构包含多种不等数量的文本数据： NewsArticle结构体在特定位置，保存着一个新闻故事；一个Tweet结构体保存着最大280个字符的字符。

现在我们想做一个媒体aggregator library(聚合库)，可以用来显示存在两种结构体中的文本数据的摘要

``` rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

在method 定义之后，我们使用分号代替在大括号内提供实现。
实现此trait的每种类型必须为method的主体提供其自己的自定义行为。

编译器会强制要求所有有Summary trait的类型，都必须有完全使用上述方法签名的summarize method。

一个trait可以在其主体中具有多种方法：方法签名每行列出一个，并且每行以分号结尾。

### 在一个类型上实现trait
上一节我们已经使用Summary trait定义了希望实现的行为，我们可以在媒体aggregator library(聚合库)上实现。
``` rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}: {}", self.username, self.content)
    }
}
}

```
在类型上实现trait类似于实现常规method。不同点在impl之后，是想要实现的trait的名字（Summary）,然后使用for关键字，后紧跟着我们想要实现这个trait的特定的类型。最后在大括号里面，指定我们想要在特殊类型上，实现的方法的具体行为。

trait实现需要注意的一个限制是，只有trait或类型在crate中是本地的，我们才能对类型实现trait。我们不能在外部类型上实现外部trait。

此规则可确保其他人的代码不会破坏自己的代码，反之亦然。如果没有该规则，两个crate可能会针对同一类型实现相同的trait，而rust不会知道要使用哪种实现。

### Default implementations
有时，对trait中的某些或所有方法具有默认行为很有用，而不是要求对每种类型的所有方法都实施实现。

为了使用默认的实现来总结NewsArticle实例，而不是定义一个自定义的实现，我们为NewsArticle {}指定了一个空的内含块，内含摘要。

默认实现可以调用具有相同trait的其他方法，即使其他方法没有默认实现也是如此。
``` rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
```
定义summary_author后，我们可以在Tweet结构的实例上调用summary，summary的默认实现将调用我们提供的summary_author的定义。

请注意，无法从相同method的重写实现中调用默认实现。

### Trait bounds
现在来讨论下，trait使用泛式类型参数。
我们可以使用trait bounds来约束通用类型，以确保该类型将被限制在那些实现特定trait和行为的类型上。

为了能在item上正确使用summarize，我么你需要在泛式类型T上使用trait  bounds，来指明item必须是一个实现了Summary trait的类型。

``` rust
pub fn notify<T: Summary>(item: T) { 
	println!("Breaking news! {}", item.summarize());
}
```
将trait bounds与泛式类型parameter的声明放在一起，放在冒号和角括号内.

可以使用 ‘+’ 语法，指定多个trait bounds 到一个泛式类型上。
例如，在使用泛式类型T作为display formatting 的类型，并使用summarize method.

⚠️⚠️⚠️
我们可以使用
``` rust
T: Summary + Display
```
来表示，泛式类型T,可以是任何同时实现了Summary和Display trait的类型。

代码简化：
```rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {
```

```rust
fn some_function<T, U>(t: T, u: U) -> i32 
	where T: Display + Clone,
        U: Clone + Debug
{
```

### 使用trait bounds有条件地实现methods
通过使用trait bounds和带泛式类型参数的的impl，我们就可以用有指定trait的类型有条件的实现methods.
``` rust
#![allow(unused_variables)]
fn main() {
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
}

For example, the type Pair<T> always implements the new function. But Pair<T> only implements the cmp_display method if its inner type T implements the PartialOrd trait that enables comparison and the Display trait that enables printing.

```
对于任何实现了另一个trait的类型，我们也可以有条件地实现一个trait。
满足trait bounds的任何类型的trait实现都称为覆盖实现，并且在Rust标准库中得到了广泛的使用。

trait和trait bounds使我们可以编写使用泛式类型参数来减少重复的代码，同时还向编译器指定我们希望泛式类型具有特定行为。

## Validating Reference with Lifetimes
在rust中，每一个reference都有一个生命周期，就是reference有效的范围。

### 防止出现reference生命周期过早结束

生命周期的主要目的，就是防止出现混乱引用，类比C的指针所指向的内容非法后，仍然可以调用指针操作。

场景类似于C语言中，函数返回一个函数内的临时指针变量。这时候程序是不稳定的。

``` rust
{
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          |
    }                         // -----
```
注释描述了变量的生命周期。

上面的代码，外部括号内定义的变量r,生命周期参考注视‘a的范围，内部括号定义了变量x，生命周期参考注释‘b的范围。

x在内部括号结束的时候，就无效了，这时候外部变量r仍然是x的引用，编译就会报错。

``` rust
$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --> src/main.rs:7:17
   |
7  |             r = &x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!("r: {}", r);
   |                           - borrow later used here
```

其实就是x变量存活的时间不够长，因为x的reference使用还没有完结。

### The Borrow Checker
将之前的代码修改为
``` rust
 {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &x;           // --+-- 'a  |
                              //   |       |
        println!("r: {}", r); //   |       |
                              // --+       |
    }                  
```

就完全没问题了，其实总结起来，任何reference的生命周期，必须要大于等于调用找个reference的操作范围。可以类比理解为不能使用一个非法指针。生命周期就是来确保这一点的。

### Generic Lifetimes in Functions
```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

error[E0106]: missing lifetime specifier --> src/main.rs:1:33
|
1 | fn longest(x: &str, y: &str) -> &str {
| ^ expected lifetime parameter
|
= help: this function's return type contains a borrowed value, but the
signature does not say whether it is borrowed from `x` or `y`
```
返回类型需要一个通用生命周期参数,因为Rust无法分辨返回的参考是x还是y.

要解决此错误，我们将添加通用的生命周期参数，这些参数定义了引用之间的关系，以便borrow checker可以进行分析。

### 生命周期注释语法
生命周期注释不会更改任何引用的有效期限。就像函数定义指定泛式类型参数时函数可以接受任何类型一样，函数可以通过指定通用生命周期参数来接受具有任何生命周期的引用。

生命周期注释语法：生命周期参数用符号 ‘ 开头，通常全部为小写字母且比较简短。将生命周期参数放在引用的&符号后面，并用一个空格隔开引用的类型。
``` rust
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

如果只是单独的使用一个生命周期参数，没有任何意义，因为生命周期参数的目的是告诉Rust多个引用的通用生命周期参数如何相互关联。

如果我们定义两个 引用具有相同的 生命周期参数，那么编译器就会认为两个引用有相同的生命周期。

### Lifetime Annotations in Function Signatures
``` rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}

fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

⚠️： <'a>
⚠️： 函数longest中的生命周期参数表示，作为输入参数的两个引用和作为返回值的引用变量，具有相同的生命周期‘a。


```

请记住，当我们在此函数中指定生命周期参数时，我们不会更改任何传入或返回的值的生命周期。

以上代码表示的意思就是，通用生命周期参数‘a的实际值应该是等于x和y,中运行时生命周期较短的那一个。因为我们申明了返回引用具有相同的生命周期参数‘a，也就是说返引用的生命周期也会等于x和y中生命周期较短的那一个。

### 结构体定义中使用生命周期注释
``` rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}

```
此注释表示ImportantExcerpt实例不能超过其在部分字段中保存的引用的寿命。

### Lifetime Elision
第一条规则是作为引用的每个参数都有自己的生命周期参数.
第二条规则是，如果仅存在一个输入寿命参数，则将寿命分配给所有输出寿命参数.
第三个规则是，如果有多个输入生存期参数，但是其中一个是＆self或＆mut self，因为这是一种方法，因此将self的生存期分配给所有输出生存期参数。

### Lifetime Annotations in Method Definitions
结构字段的生命周期名字，必须要申明在关键字impl之后，然后在结构体名称后调用，因为这些生命周期是结构类型的一部分。
``` rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

impl<'a> ImportantExcerpt<'a> {
    fn level(&self) -> i32 {
        3
    }
}

impl<'a> ImportantExcerpt<'a> {
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}

```

### 静态生命周期
这意味着该带有静态生命周期的引用可以在程序的整个过程中有效。
``` rust
let s: &'static str = "I have a static lifetime.";
```

## Generic Type Parameters, Trait Bounds, and Lifetimes Together
``` rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest_with_an_announcement(
        string1.as_str(),
        string2,
        "Today is someone's birthday!",
    );
    println!("The longest string is {}", result);
}

use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where //简化代码不要让函数申明过长
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

```

## 总结
* 泛式类型参数使您可以将代码应用于不同类型。
* traint和trait bounds可确保即使类型是泛式类型，它们也将具有代码所需的行为。
























